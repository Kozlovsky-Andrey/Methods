"# Methods" 
// Методы всегда работают с сравнениями (===) !!!!!!!!!!!!!!!!!!!!!!!!!

// ===================================================================================
// =============== Создание массива ==================================================
// ======================================================================================

// let arr = new Array();  // let arr = [];   <-- Это две равнозначные записи.
// let arrN = new Array(10); // Создание массива из десяти пустых элементов (undefined).
// let arrN = new Array(10, 3, 5, 6, "str", null, false); // Создание массива со значениями.

                             // Т.к. массив это objeсkt, то его свойства можно изменить
// arrN.length = 3;              // Например здесь, массив обрезается после первых двух элементов. 
                              // Но таким образом, весь остальной массив будет утерян.
// arrN.length = 0;  // Обнуляет массив.                              
// console.log(arrN.length);  // Выводит количество элементов массива. 

// console.log(arr[arrN.length - 1]);  // Способы обращения к элементам массива.
// console.log(arrN.at(-1));



// =============================================================================
// ========== Методы pop/push, shift/unshift ===================================
// =============================================================================

// ----------------------------------------------------------------------------
// -------- push  ->  добавляет элемент(ы) в конец.----------------------------
// -------- pop ->  удаляет последний элемент (и возвращает этот элемент!) ----

// const letters = ['a', 'b', 'c', 'd', 'e'];
// console.log(letters);
// letters.push('f', 's', 1, 5);
// letters.push(88)

// console.log(letters);

// let c = letters.push('g');  // Эта строка присваивает переменной "с" значение переменной "letters" и одновременно добавляет элемент
// console.log(c);           // return quantity of elements (возвращаемое количество элементов)

// //
// let a = letters.pop();     // Эта строка присваивает переменной "а" значение переменной "letters" и одновременно удаляет последний элемент
// console.log(letters);
// console.log(a);           // return deleted element (показывает удалённый элемент)


// let arr = [];
// arr.push('string', 10, 65, true, [2, 4, 5]);
// console.log(arr[4].pop());   // Эта команда удаляет последний элемент во вложенном массиве!!!
// console.log(arr);


// ---------------------------------------------------
// ----- push() -------------------------------------- 
// ----- push() добавляет элемент в конец массива ----

//  const arr1 = [1, 2, 3];
//  const arr2 = ['a', 'b', 'c'];
// arr1.push(arr2, 5, {1: "st", 2: "st"});        // push просто добавил массив arr2  в массив arr1, как единый элемент
// console.log(arr1);
// console.log(arr1.push(100));  // Эта строка добавляет в массив "100". Но не выводит сам массив, поэтому "100" мы не видим.
//                               // А на вывод идёт число, показывающее общее количество элементов в массиве (вместе со "100").
// console.log(arr1);

// -----------------------------------------------------
// --- push() + spread operator ... --------------------

// arr1.push(...arr2);   // (...arr2) ==> ('a', 'b', 'c') -->
// console.log(arr1);    // --> [ 1, 2, 3, 'a', 'b', 'c' ]

// ---------------------------------------------------
// --- через третий массив ---------------------------

// const arr3 = [...arr1, ...arr2];
// const arr4 = [1, 2, 3, 'a', 'b', 'c']
// console.log(arr3 );
// console.log(arr4)


// ---------------------------------------------------------------------------------------
// ---- unshift -> Добавляет элемент(ы) в начало массива ---------------------------------
// ---- shift удаляет элемент в начале, сдвигая очередь, так -----------------------------
// ---- что второй элемент становится первым (и возвращает этот элемент!) ----------------

// const bigLetters = ['A', 'B', 'C', 'D', 'E'];

// bigLetters.unshift('Z');
// let d = bigLetters.unshift('X', 'Y');   //return quantity of elements (возвращаемое количество элементов)
// console.log(bigLetters);
// console.log(d)                          //return quantity of elements (возвращаемое количество элементов)

// let b = bigLetters.shift();  // выводит массив без удалённого элемента и сам элемент, вне массива
// console.log(bigLetters, b);  // [ 'B', 'C', 'D', 'E' ] A

// let b = bigLetters.shift();       // Но, это можно сделать и по отдельности
// console.log(bigLetters);
// console.log(b)


// let arr = ['string', 10, 65, true, [2, 4, 5]];

// arr.unshift(4);
// console.log(arr);
// console.log(arr.shift());  // Эта команда показывает сколько элементов осталось в массиве.



// ===============================================================================
// ====== объединение массивов ===================================================
// ====== concat() =================================================================
// ===============================================================================


// let arr = ['string', 10, 65, true, [2, 4, 5]];
// let arr1 = [2, 3, 4, 5,];
// let arrStr = ['wr', 'rt', 're'];

// let newArr = arrStr.concat(arr, arr1);   // Массивы объединяются именно в том порядке, в котом написаны (arrStr + arr + arr1).
// console.log(newArr);

// ===============================================================================
// ====== объединение массивов ===================================================
// ====== concatenation - не используется! =======================================
// ===============================================================================


// const letters = ['a', 'b', 'c', 'd', 'e'];
// const bigLetters = ['A', 'B', 'C', 'D', 'E'];
// console.log(letters + " " + bigLetters);   // строка!!!  a,b,c,d,e A,B,C,D,E
// console.log(letters, bigLetters);          // просто два массива   [ 'a', 'b', 'c', 'd', 'e' ] [ 'A', 'B', 'C', 'D', 'E' ]
// console.log(String(letters));        // convert to string (конвертирует в строку)

// console.log(String(7));
// let num = String(7)
// let num2 = 5
// console.log(num + num2)       // Вместо сложения, здесь идёт конкратинация строк "75"



// ===================================================================================
// ========== Метод переварачивающий массив (пишет задом наперёд) ====================
// ========== .reverse(); ==============================================================

// let arr1 = [2, 3, 4, 5,];  // Иногда на работе нельзя изменять целевой массив (изначальный),
//                            // в таком случае, для revrse() лучше создать копию.

// arr1.reverse();     // При использовании этой команды, по сути создаётся новый массив.
// console.log(arr1);  // И меняется ссылка на него, и в псоледующих операциях JS будет работать с этой ссылкой (с новым массивом).


// Переворячивание массива не используя .reverse();
// https://uproger.com/perevorachivaem-massiv-v-javascript/?ysclid=l97ghicrn1244974081

// reverse = function(array) {
//   return array.reduceRight(function(a, v){ return a.push(v), a }, []);
// }

// reverse = function(array) {
//     return array.map((c, i) => array[array.length - 1 - i]);
//   }

// reverse = function(array) {
//     var result = [];
//     array.forEach(function(value) { result.unshift(value); });
//     return result;
//   }





// ==============================================================
// ========= split() == and == join() ===========================
// ==============================================================

// --------------------------------------------------------------
// ----------- split() --- separator (разделитель) --------------

// ---- split(); делит строку по указанному разделителю, возвращает массив
// ---- split("");  => возвращает массив разделив все элементы по отдельности

// let string = "Hello World";
// console.log(string);

// console.log(string.split(""));
// let stringNew = string.split(" ") //  Эта строка пересоздаёт "тело" переменной string из строки в массив
// console.log(stringNew);        // Создаётся конвертация из строки в массив

// let newArrayFromString = string.split(" ")
// console.log(newArrayFromString);


// -----------------------------------------------------------------------------------
// --- join(); конвертирует массив в строку, по умолчанию ----------------------------
// --- разделяет символы запятой , but do not changeit (но не меняет его) ------------
// --- join() - separator (разделитель) ----------------------------------------------
 
// let array = ['a', 'b', 'c', 1, 2, 3];
// console.log(array);

// console.log(array.join());
// console.log(array);

// let newStringFromArray = array.join("")  // Опять же, эта строка конвертирует переменную с массивом в строку
// console.log(newStringFromArray)




// ======================================================================================
// ============ .slice() ================================================================
// --- Slice out a portion of a string from position 7 to position 13(13 not included):
// --- Отрежьте часть строки от позиции 7 до позиции 13 (13-я позиция не включена) --------------


// Ситаксис --> .slice([start], [end]) 

// let str = "Apple, Banana, Kiwi";
// let part = str.slice(7, 13);
// console.log(str);             // Apple, Banana, Kiwi
// console.log(part);            // Banana

// let str = 'Hello World';
// const arr = str.split('');
// console.log(arr);
// // Ситаксис --> .slice([start], [end])
// const newArr = arr.slice(2, 5);
// console.log(newArr);
// const newArr = arr.slice(2);  // При таком написании, с одной цифрой, вырежется весь массив, начиная со второго элемента.
// const newArr = arr.slice(-6); // Так же можно работать с отрицательными индексами.

// const newArr = arr.slice();   // Если оставить скобки пустыми, то массив продублируется.
                                 // Это один из самых быстрых способов дублирования массива.



                                 

// ========================================================================================
// =========== .splice() === Удаляет и заменяет, одновременно =============================
// ========================================================================================

// Синтаксис --> .splice(index, deleteCount, el1, el2, ..., elN);
// Начинает с позиции index, удаляет указаное число элементов (deleteCount), и затем
// вставляет элементы, которые мы передали (el1, el2, ..., elN), на это место.

// let str = 'Hello World';
// const arr = str.split('');
// console.log(arr);
// Синтаксис --> .splice(index, deleteCount, el1, el2, ..., elN);
// const newArr = arr.splice(1, 3, "E", "L", "L"); // Эта команда удаляет и заменяет.
// console.log(newArr);                            // А эта команда показывает, что было удалено.

// arr.splice(1, 3, "E", "L", "L"); // Эта команда удаляет и заменяет.
// console.log(arr);                // А эта показывает новый массив.

// работа с числами. ---------------------------------------------------

// let arr = [1, 2, 3, 7];
// arr.splice(3, 0, 4, 5, 6);
// console.log(arr);
// Начинает с позиции 3, удаляет указаное число элементов (0), и затем
// вставляет элементы, которые мы передали (4, 5, 6), на это место.




// =============================================================================================
// ======= .indexOf(); = .lastIndexOf(); = .includes(); ========================================
// =============================================================================================

// ------------------------------------------------------------------------------------------
// ----------- .indexOf(); ------------------------------------------------------------------

// Данный индекс ищет вхождение элемента и возвращает индекс этого вхождения
// Синтаксис --> .indexOf(item, fromIndex); // Первое, что мы ищем (item), второе, индекс найденного элемента (fromIndex).
// Если ничего не было найдено, возвращается минус один (-1).

// const arr = "Hello World!".split('');
// console.log(arr);

// let index = arr.indexOf('l', 4); // Эта команда предлагает искать букву 'l' с 4-го индекса.
// let index = arr.indexOf('l'); // Эта команда ищет до первого совпадения и останавливается.
// console.log(index);

// let i = arr.indexOf('l');          // Подобное условие while
//                                    // нужно создать для поиска
// while (i != -1) {                  // по всей переменной.
//     console.log(i);                //
//     i = arr.indexOf('l', i + 1);   //
// }                                  //
// Так же этот метод работает с boolen(ами). 
// Можно искать утверждения let i = arr.indexOf(false);


// -------------------------------------------------------------------------
// ------------- .lastIndexOf(); -------------------------------------------
// ---------- Работает с конца ---------------------------------------------

// const arr = "Hello World!".split('');
// console.log(arr);

// let index = arr.lastIndexOf('l', 8);   // Эта команда предлагает искать букву 'l' с 8-го индекса.
// let index = arr.lastIndexOf('l');         // Эта команда ищет до первого совпадения и останавливается.
// console.log(index);


// ------------------------------------------------------------------------------
// -------------- .includes(); --------------------------------------------------
// ----------- Проверяет, входит ли элемент в наш массив ------------------------
// Если входит (true), если элемента в массиве нет (false).

// const arr = "Hello World!".split('');
// console.log(arr.includes('l'));       //  true
// console.log(arr.includes('L'));       // false
// // Единственная переменная, которая не равна самой себе, это NaN !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// console.log(NaN == NaN);    // false
// console.log(NaN === NaN);   // false
// // НО!
// const arr = "Hello World!".split('');  //  Подобная "махинация"
// arr.push(NaN);                         // выведет
// console.log(arr.includes(NaN));        //         true




// ==================================================================================
// ============== .find(); === .findIndex(); ========================================
// ==================================================================================

// ------------------------- Здесь уже начинаются callback(и) -----------------------

// ----------------------------------------------------------------------------------
// -----------.find(); --------------------------------------------------------------
// Метод .find() вернёт первый найденный в массиве элемент, 
// который подходит пол заданные условия, передаваемые функцией.

// // Синтаксис --> .find(function(element, index, array) {...}));
// const arr = [2, 3, 8, 10, 11, 13];
// // num % 2 != 0  // Поиск нечётного числа.
// console.log(arr.find(el => el % 2 != 0));   // Если число не найдено, то выводится "undefined".
// // вместо 'el' можно использовать           // Если число найдено, то выводится само число.
// // лубое обозначение (например "х").        // Выводится первое найденое (поиск идёт слева на право).

// --------------------------------------------------------------------------------------
// ------------------ .findIndex(); -----------------------------------------------------
// ----- Возвращает индекс первого найденого элемента, отвечающево условию --------------
// ----- Но, если такой элемент не находится, возвращается -1 (минус один). -------------

// const arr = [2, 3, 8, 10, 11, 13];
// // // num % 2 != 0  // Поиск нечётного числа.
// console.log(arr.findIndex(el => el % 2 != 0));  
// // Возвращает index - "1", индекс числа "3".




// ==========================================================================================
// =================== .filter(); ===========================================================
// ====== Возвращает новый массив отфильтрованных элементов, которые ========================
// ====== будут задаваться в callback функции ===============================================

// Синтаксис --> .filter(function(element, index, array) => {условие}));
// const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];

// const arrOdd = arr.filter(el => el % 2 != 0);  // Возвращает [ 1, 3, 5, 7, 9 ]
// console.log(arrOdd);

// const arr = [1, 'str', null, 4, true, 6, NaN, 8, 9, 'Hello!'];
// const arrOdd = arr.filter(el => typeof el == 'string');        // Возвращает [ 'str', 'Hello!' ]
// console.log(arrOdd);                  // или 'numbers'




// ==============================================================================
// =================== .every(); ======= .some(); ===============================
// ==============================================================================

// --------------------------------------------------------------------------------
// ---------------- .every(); -----------------------------------------------------
// ---- Every говорит, что все элементы должны отвечать условию -------------------
// ---- Если все элементы соответствуют условию, результат будет true -------------
// ---- В ином случае, результат будет false --------------------------------------

// const arr = [1, 8, 9, -2, 0, 5];
// console.log(arr.every(el => el > 0)); // Возвращает false

// const arr = [1, 8, 9, 2, 0, 5];
// console.log(arr.every(el => el >= 0)); // Возвращает true


// --------------------------------------------------------------------------------
// ------------------- .some(); ---------------------------------------------------
// ----- .some(); говорит, что КАКИЕ-ТО элементы соответствуют условию ------------
// ----- Если ХОТЬ ОДИН элемент соответствует условию, результат будет true -------
// ----- Если НИ ОДИН не соответствует условию, результат будет false -------------

// const arr = [1, 8, 9, -2, 0, 5];
// console.log(arr.some(el => el < 0)); // Возвращает true

// const arr = [1, 8, 9, 2, 0, 5];
// console.log(arr.some(el => el < 0)); // Возвращает false



// ======================================================================================
// ==================== forEach(); = для каждого ========================================
// ===== Позволяет применить функцию callback ко всем элементам массива =================
// ===== Но эта функция ничего не возвращает, это означает, что console.log нужно прописывать в теле решения (метода) 

// например мы можем поменять число у каждого элемента массива
// const arr = [-1, -8, -9, -2, 0, -5];

// const changeSign = function (el) {   // Эта функция меняет "полюс" числа
//     console.log(-el);                  
// }
//changeSign(arr[1]); 
// ---- Стрелочный вариант функции -----------------
// const changeSign = el => console.log(-el);

// arr.forEach(changeSign)  // Этот метод позволяет, используя функцию выше, обратиться к каждому элементу массива

// Упрощённый вариант ---------------

// arr.forEach(function (el) {   
//     console.log(-el);                  
// })
// Упрощённый вариант 2 -------------------
// arr.forEach(el => console.log(-el));  // Лучше использовать такой вариант, с безымянной функцией

// ------ Изменение чисел с чётным индексом -----------
// const arr = [-1, -8, -9, -2, 0, -5];
// arr.forEach((el, i) => i % 2 == 0 ? console.log(-el): console.log(" "));

// ----- Возведение каждого элемента в куб ------------
// const arr = [-1, -8, -9, -2, 0, -5];
// arr.forEach(el => console.log(el ** 3));

// ----- Возведение в квадрат чисел под нечётными индексами и прибавления длинны массива ------------
// const arr = [-1, -8, -9, -2, 0, -5];
// arr.forEach((el, i, newArr) => i % 2 != 0 ? console.log((el ** 2) + arr.length) : console.log(" "));
//               // Массиву внутри можно присвоить любое имя, оно просто переприсвоится.

// --------------------------------
// const arr = [-1, -8, -9, -2, 0, -5];
// arr.forEach((el, i, newArr) => i % 2 != 0 ? console.log("Odd") : console.log("Even"));





// ===============================================================================================
// =========== .sort(); === сортировка ===========================================================
// ===== Отсортированный массив меняется, а к исходному мы уже теряем доступ ======================

// const arr = ["Anna", "Steve", "Jane", "Serg"];

// console.log(arr.sort());    // Если не вводить ни каких условий, то этот метод отсортирует в алфавитном порядке по умолчанию.

// -------- Сортировка в обратном порядке -------------------
// const arr = ["Anna", "Steve", "Jane", "Serg"];
// console.log(arr.sort().reverse());             // Если метод выводит результат, то такие методы можно чередовать.

// ----- Работа с числами ------------------------------------
// const arrNum = [1, 30, 23, 24, 65, 10, 9, 3];
// console.log(arrNum.sort());                     // По умолчанию, сортировка идёт по первому символу - 1, 2, 3,...

// ----- Сортировка от меньшего к большему ---------------------
// const arrNum = [1, 30, 23, 24, 65, 10, 9, 3];
// console.log(arrNum.sort((a, b) => a - b));      // а - воспринимается как меньшее, b - воспринимается как большее (a - в алфавите под номером 1, b - в алфавите под номером 2)

// -------- Вывод максимального и наименьшего элемента в массиве --------------
// const arrNum = [1, 30, 23, 24, 65, 10, 9, 3];
// console.log(arrNum.sort((a, b) => a - b)[0]);   // Наименьшего  // Буквы можно заменить на n1 - n2
// console.log(arrNum.sort((a, b) => b - a)[0]);   // Наибольшего  //                         n2 - n1
// С отрицательными индексами метод не работает





// =====================================================================================
// ========== .map(); ==================================================================
// ==== Метод применятеся к каждому элементу и возвращает в массив результат ===========
// ==== выполнения функции =============================================================


// ------ Узнать длинну каждого элемента ---------------
// const arr = ["JavaScript", "Java", "Python", "English", "SQL"];
// console.log(arr.map(el => el.length));

// ---- Видоизменение нашего массива ---- Добавление ** к первому и последнему эдементу ---------------
// const arr = ["JavaScript", "Java", "Python", "English", "SQL"];
// console.log(arr.map((el, i, arr) => i == 0 || i == (arr.length - 1) ? `**${el}**` : el));

// ------ Возведение каждого элемента в квадрат -----------------------
// const arrNum = [1, 3, 6, 8];
// const newArr = arrNum.map(item => item ** 2);
// console.log(newArr);

// ----- На работе часто инфа приходит в виде строк, а нам нужны числа ---------------
// const arrNum = ['1', '3', '6', '8'];
// const newArr = arrNum.map(item => Number(item));
// console.log(newArr);
// ---- Можно записать попроще -----------
// const arrNum = ['1', '3', '6', '8'];
// const newArr = arrNum.map(Number);
// console.log(newArr);
// ---- Ещё один вариант -----------------
// const arrNum = ['1', '3', '6', '8'];
// const newArr = arrNum.map(el => +el);
// console.log(newArr);





// =======================================================================================
// ========= .reduce(); === .reduceRight(); ==============================================
// ========= Это методы с четырьмя параметрами. это ВАЖНО !!! ============================
// ===== Методы используются для вычисления единого значения на основе всего массива =====

// .reduce(); идёт слева на право. ----------------------\
// .reduceRight(); идёт справа на лево. -----------------/

// --------- .reduce(); ------------------------------------------------------
// --------- .reduce((accumulator, el, index, array) => {...}); --------------

// ----- Получение суммы элементов массива -----------------------------------
// const arrNum = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// const result = arrNum.reduce((sum, el) => sum + el);  // sum += el
// console.log(result);

// Иногда, на ID или например Codewars при работе с большими массивами у которых перекликаются названия переменных.
// Например, часто используется sum. И суммы могут неправильно сосчитаться. И для устранения этого недостатка
// у нас есть ещё один аргумент.
// .reduce((accumulator, el, index, array) => {...} ,[initial value]);
//                                                  ----------------
// Этим инициализируем sum до начала работы метода.
// const arrNum = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// const result = arrNum.reduce((sum, el) => sum + el, 0);  // То есть sum, до начала вычисления, присваивается ноль(0)
// //                                                ----
// //                                        sum = 0; --> el = 1; --> sum += el --> sum = 1;
// //                                                     el = 2; --> sum += el --> sum = 3;
// console.log(result);

// ---- Подсчитать среднее от массива ----------------------------
// const arrNum = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// let sum = 0;
// for (let i = 0; i < arrNum.length; i++) {
//     sum += arrNum[i];
// }
// console.log(sum / arrNum.length);

// // ---- с помощью метода --------------------------------
// const arrNum = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
// console.log(arrNum.reduce((acc, el, i, arr) => i === (arr.length - 1) ? (acc + el) / arr.length : acc + el, 0));

// // ----- Решение попроще ---------------------------
// const arrNum = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
// console.log(arrNum.reduce((acc, el, i, arr) => acc + el / arr.length, 0));
// // -------- ИЛИ ----------------------------
// const arrNum = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
// console.log(arrNum.reduce((acc, el) => acc + el, 0) / arrNum.length);





// ===========================================================================
// === статический метод Array.from(); =======================================
// === Предназначен для создания массива на основе передаваемого объекта или какого-то значения

// const arr = Array.from("JavaScript");  // выводит [    'J', 'a', 'v', 'a', 'S', 'c', 'r', 'i', 'p', 't'  ]
// console.log(arr);  

// // ---- Создание массива из 20-ти элементов ------------
// const arr = Array.from(Array(20));    
// /*
//  [
//     undefined, undefined, undefined,
//     undefined, undefined, undefined,
//     undefined, undefined, undefined,
//     undefined, undefined, undefined,
//     undefined, undefined, undefined,
//     undefined, undefined, undefined,
//     undefined, undefined
//   ]
// */ 
// console.log(arr); 
// // ---- Но это особо и ненужно, т.к. можно сделать тоже самое проще -------
// const arr = Array(20);   // [ <20 empty items> ]
// console.log(arr);        // Это тоже самое, просто на выводе undefined не видно.

// // ---- Но этот массив можно наполнить значениями ----------
// const arr = Array.from(Array(20).fill(0));   // Например нулями
// console.log(arr);

// const arr = Array.from(Array(20).fill("str"));   // Или строками
// console.log(arr);

// // ---- Но лучше это действие скомбинировать с методом .keys(); ----
// const arr = Array.from(Array(20).keys()); 
// console.log(arr);
// /*
// [
//    0,  1,  2,  3,  4,  5,  6,
//    7,  8,  9, 10, 11, 12, 13,
//   14, 15, 16, 17, 18, 19
// ]
// */
// const arr = Array.from(Array(20 + 1).keys()); 
// console.log(arr);
// /*
// [
//    0,  1,  2,  3,  4,  5,  6,
//    7,  8,  9, 10, 11, 12, 13,
//   14, 15, 16, 17, 18, 19, 20
// ]
// */

// // ------- Создание массива от определённого числа, до определённого числа ------
// let start = 10;
// let finish = 25;

// const arr = Array.from(Array(finish - start + 1).fill(start), (el, i) => el + i);
// console.log(arr);

// // ----- ИЛИ ----------------
// let start = 10;
// let finish = 25;

// const arr = Array.from(Array(finish - start + 1).fill(start)).map((el, i) => el + i);
// console.log(arr);

// // ---- Так же массив можно заполнить, через spred оператор ------------
// console.log([...Array(11).keys()]);
// /*
// [
//    0, 1, 2, 3, 4,
//    5, 6, 7, 8, 9,
//   10
// ]
// */
// console.log([...Array(11 + 1).keys()]);
// /*
// [
//    0,  1, 2, 3, 4,
//    5,  6, 7, 8, 9,
//   10, 11
// ]
// */




// =========================================================================================
// ========= Array.of(); ===================================================================
// ==== Создание массива и Передача значений в массив именно в том виде, в котором вы их написали

// const arr = Array.of(10, 15, 34, 76, "Anna", null, NaN);
// console.log(arr);




// ==================================================================================
// =========== Array.isArray(); =====================================================
// ===== Передаёт true либо false, по результатам проверки, которая проводится в этом методе

// let arr = Array.of(10, 15, 34, 76, "Anna", null, NaN);
// console.log(Array.isArray(arr));  // true

// let arr = Array.of(10, 15, 34, 76, "Anna", null, NaN);     // Иногда нам нужно проверить, действительно ли
// arr = null                                                 // нам пришёл массив (или строка и т.д.).
// console.log(Array.isArray(arr));  // false




// ================================================================================
// =========== Math.min(); === Math.max(); ========================================
// ================================================================================

// let arr = [10, 15, 34, 76];

// let min = Math.min(...arr);
// let max = Math.max(...arr);



// ================================================================================
// ===================== Math.pow(); ==============================================
// ============= Возведение в степень =============================================

// console.log(Math.pow(2, 4));
// console.log(2 ** 4);




// ====================================================================================
// ================= Math.sqrt(); =====================================================
// ============ Квадратный корень из числа ============================================

// console.log(Math.sqrt(25));
// console.log(25 ** 1/2);




// ====================================================================================
// ===== Math.floor(); === Math.ceil(); === Math.round(); === Math.trunc(); ===========
// ====================================================================================

// ----- Math.floor(); ---- Округляет число в меньшую сторону ----------------

// let num = 6.893;
// console.log(Math.floor(num));  // выдаёт 6


// ------- Math.ceil(); ---- Округляет в большую сторону ------------------------

// let num = 6.293;
// console.log(Math.ceil(num));  // выдаёт 7


// ------ Math.round(); ---- Округляет от середины числа, в меньшую и в большую стороны --------------

// let num = 6.499;
// let num1 = 6.501;

// console.log(Math.round(num));   // Выводит 6
// console.log(Math.round(num1));  // Выводит 7


// --------- Math.trunc(); ------ Отбрасывает дробную часть ---------------

// let num = 6.899;
// let num1 = 7.101;

// console.log(Math.trunc(num));   // Выводит 6
// console.log(Math.trunc(num1));  // Выводит 7



// ==============================================================================
// ============= .toFixed(); ====================================================
// ====== Обрезает число до N знаков после запятой, которые указаны в скобках ===
// ====== И округляет на одну (деятую/сотую/...), и возвращает число в виде СТРОКИ !!!!!!!!!!!!!!!!!

// let num = 6.879;
// console.log(num.toFixed(2));
// console.log(+num.toFixed(2)); // Если прописать плюс "+", то результат уже выдаст число.




// ==============================================================================
// =============== Math.sign(); =================================================
// ==== Возвращает знак числа. Если это отрицательное число, вернёт -1 ==========
// ==== Если это положительное число, вернёт 1 ==================================
// ==== Если это ноль, вернёт 0 =================================================

// let num = -6.899;
// let num1 = 7.101;
// let num2 = 0;

// console.log(Math.sign(num));   // Выводит -1
// console.log(Math.sign(num1));  // Выводит 1
// console.log(Math.sign(num2));  // Выводит 0




// ==============================================================================
// ================= isFinite(); ================================================
// ======= Показывает нам, чо нам пришло конечное числовое значение =============

// console.log(isFinite(545)); // Выводит true
// console.log(isFinite(-545)); // Выводит true
// console.log(isFinite(545/0)); // Выводит false   здесь получится "бесконечность/infinity", не конечное числовое значение
// console.log(isFinite(545/5)); // Выводит true
// console.log(isFinite(545/'5')); // Выводит true   здесь срабатывает приведение типов
// console.log(isFinite(545/'a')); // Выводит false   здесь получается NaN
// console.log(isFinite(545/'5a')); // Выводит false   здесь получается NaN




// ===============================================================================
// =========== parseFloat(); === parseInt(); =====================================
// ======= Вытаскивают из строк числа ============================================

// ----- parseFloat(); ------ Вытаскивает дробные числа --------------------------

// let str = '1000.546px';
// let str1 = '1000.546.0099px';
// let str2 = 'p1000.546px';

// console.log(parseFloat(str));   // Выводит 1000.546
// console.log(parseFloat(str1));  // Выводит 1000.546   // После второй точки не видит. Непонимает, что это такое. Так числа не пишутся.
// console.log(parseFloat(str2));  // Выводит NaN        // Видит числа, только если первый знак, это число.


// ------- parseInt(); ---- Вытаскивает целые числа -------------------------------

// let str = '1000.546px';
// let str1 = '1000.546.0099px';
// let str2 = 'p1000.546px';

// console.log(parseInt(str));   // Выводит 1000
// console.log(parseInt(str1));  // Выводит 1000  // 
// console.log(parseInt(str2));  // NaN

// ------- Так же parseInt(); может работать с таблицей ASCII -----------------------

// let str = '4a';
// console.log(parseInt(str, 16));  // Шестнадцатиричный код. Выводит 74
